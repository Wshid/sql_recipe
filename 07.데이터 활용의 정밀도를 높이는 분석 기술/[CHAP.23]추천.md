# 23. 추천
- 추천 시스템(Recommendation System)
  - 사용자의 **흥미 기호**를 분석해서,
  - 사용자가 관심을 가질만한 정보를 추출하는 것이 아닌
    - **사용자에게 가치 있는 정보를 추천하는 것**으로 정의
  - 이를 활용하면
    - 사용자가 아직 모르는 정보를 알려주어, 구매를 유도할 수 있음
- 이번 절에서는
  - 추천에 관련한 기본적인 내용과
  - Item to Item, User to Item 추천 리스트 만들기
- 샘플 데이터
  - 아이템 열람/구매 로그(action_log)
    - stamp, user_id, action, product

## 1. 추천 시스템의 넓은 의미
- 추천 시스템의 의미는 **좁은 의미**와 **넓은 의미**가 다르기 때문에, 혼동될 수 있음
- 넓은 의미의 추천 시스템을 사용하여
  - 추천 시스템의 종류, 모듈, 효과, 정밀도를 살펴보기

### 추천시스템의 종류
- 두가지 종류
  - `Item to Item`
    - 열람/구매한 아이템을 기반으로 다른 아이템을 추천
    - 아이템과 관련한 개별적인 아이템 제안
    - e.g. 이 상품을 본 사람들은 다음 상품도 보았습니다.
  - `User to Item`
    - 과거의 행동 또는 데모그래픽 정보를 기반으로, 흥미와 기호를 유추, 아이템 추천
    - 사용자 개인에 최적화된 아이템 제안
    - e.g. 당신을 위한 추천 아이템 
- `당신을 위한 추천 아이템`이라 적혀 있더라도,
  - 내부 로직이 **최근 구매한 아이템**을 기반으로 다음 아이템을 추천하는 것이라면
  - Item to Item을 의미
- `Item to Item`과 `User to Item`은
  - 모두 상품 또는 기사 단위의 추천이 아니더라도,
  - 상품 카테고리 또는 지역 추천 같은 **포괄적인 추천**도 추천의 대상으로 삼음
- `User to Item`처럼 사용자 **행동**을 기반으로 흥미 기호를 추천하는 경우,
  - 데이터가 적은 사용자에 대해서는 **흥미 기호**를 제대로 판단할 수 없으므로 주의 필요

### 모듈의 종류
- 일반적으로 사용되는 `EC 사이트`에는 어떤 추천 모듈이 있는지 구분
- 모듈의 종류

**모듈**|**설명**|**예**
-----|-----|-----
리마인드|사용자의 과거 행동을 기반으로 아이템을 다시 제안|최근 보았던 상품 / 한 번 더 구매하기
순위|열람 수, 구매 수 등을 기반으로 인기 있는 아이템을 제안해주는 것|인기 순위 / 급상승 순위
콘텐츠베이스|아이템의 추가 정보를 기반으로 다른 아이템을 추천해주는 것|해당 배우가 출연한 다른 작품
추천|서비스를 사용하는 사용자 전체의 행동 이력을 기반으로, 다음에 볼만한 아이템 또는 관련 아이템을 추측해 제안해주는 것|이 상품을 보았던 사람들은 이러한 상품들도 함께 보았습니다
개별 추천|사용자 개인의 행동 이력을 기반으로 흥미 기호를 추천하고, 흥미 있어 할 만한 아이템을 제안해주는 것|당신만을 위한 추천

- 어려운 계산 로직을 사용하지 않더라도
  - `과거에 출력한 정보를 여람 이력으로 출력해주는 모듈`도 `리마인드 목적의 추천 모듈`로 구분
- 예시
  - `매출`또는 `열람 수`에서 상위를 차지하는 몇 개를 출력해주는 것 역시 **순위**를 사용한 추천
    - 매출 또는 열람 수의 상위를 구하는 방법은 **CHAP.10**, **CHAP.14.2**에서 소개됨
  - 추가로 **계절성**을 중시하는 순위라면
    - **CHAP.10.3**에서 소개한 **증가율**을 정렬 점수로 사용하여
      - **급상승 순위**와 동일한 모듈 사용 가능
- 추천/개별 추천(Personal Recommendation)은 **23.2, 23.3**에서 소개

### 추천의 효과
- 추천 시스템은
  - 정보가 과다한 상태에서 **사용자가 가치있는 정보를 쉽게 접하도록** 도와주는 기능
- 이외에도 `EC 사이트`에서 추천의 효과는 다음과 같음

**효과**|**설명**|**출력 예**
-----|-----|-----
다운셀|가격이 높아 구매를 고민하는 사용자에게 더 저렴한 아이템을 제안해서 구매 수를 올리는 것|이전 모델이 가격 할인을 시작했습니다
크로스셀|관련 상품을 함께 구매하게 해서 구매 단가를 올린느 것|함께 구매되는 상품이 있습니다
업셀|상위 모델 또는 고성능의 아이템을 제안해서 구매 단가를 올리는 것|이 상품의 최신 모델이 있습니다

- 예시(햄버거 가게 이야기)
  - `햄버거와 함께 프렌치프라이는 어떤가요?` -> **크로스셀**
  - `500원만 추가하면 프렌치프라이 사이즈를 L로 변경할 수 있습니다` -> **업셀**
  - `작은 사이즈의 커피가 있는데, 가격이 더 저렴합니다` -> **다운셀**
- 사용자가 한 번 방문할 때마다 **이동률**과 **열람 수**를 올리려면
  - 새로운 상품 또는 인기 상품 이외에도
  - 열람수가 적은 상품을 추천해 **새로운 발견**(의외성)을주어야 함
- 이처럼 추천 시스템을 구축할 때는
  - 그 목적을 **명확**하게 하는 것이 중요

### 데이터에 따라 얻을 수 있는 정밀도와 효과의 차이
- 추천 시스템을 구축할 때 중시해야할 점은
  - **어떤 데이터**를 기반으로 **추천 시스템**을 구축할 것인가
- 기존에는 db에 저장된 구매 데이터, 회원 데이터만 사용할 수 있었으나,
  - 최근에는 빅데이터 기술의 진보로 **상품 열람 로그**도 다룰 수 있게 됨
- 사용할 수있는 각종 데이터를 어떻게 수집하고
  - 어떻게 사용할지에 따라 얻는 효과가 다름

#### 데이터의 명시적 획득과 암묵적 획득
- 추천 시스템 구축시 사용할 데이터 수집 방법(2)
  - **사용자 행동**에서 기호를 추측하는 **암묵적인 데이터 획득**
  - 사용자의 기호를 직접 묻는 **명시적 데이터 획득**

**데이터 기반**|**설명**|**데이터 예**
-----|-----|-----
암묵적 데이터 획득|사용자의 행동을 기반으로 기호를 추측한다<br />데이터 양이 많지만 정확도가 떨어질 수 있다|구매 로그<br/>열람 로그
명시적 데이터 획득|사용자에게 직접 기호를 물어본다<br />데이터양이 적지만 평가의 정확성이 높다|별점 주기

- 암묵적 데이터 획득은
  - 구매 했다면 **분명 이상품에 기호가 있을 것이다**라는 전제를 기반으로
  - **구매 데이터**를 추천 시스템의 데이터 소스로 활용
  - 단, 상품 구매가 **반드시 사용자의 기호와 이어지는지는 불분명**
    - e.g. DVD를 구매했으나, 재미 없었음 등
- 명시적 데이터 획득
  - `별점 주기`등을 사용해서, 사용자의 기호를 정확하게 수집하는 방법
  - 사람들이 별점을 주지 않는 경우도 많으므로, 암묵적 데이터 획득보다 **데이터 수가 적음**
- 추가로 추천 시스템 중에는 **무엇을 기반으로 추천**하는지 알려주어
  - 사용자를 납득시키는 경우도 존재
- 단, 명시적으로 획득한 데이터는 **근거**를 보여도 문제가 없으나
  - 암묵적 데이터의 경우, 사용자가 **사생활 침해**로 여길 수 있음

#### 열람 로그와 구매 로그 차이
- 암묵적 데이터를 사용할 경우, **열람 로그**와 **구매 로그**중에
  - 무엇을 사용할지에 따라 추천되는 정보가 다를 수 있음 

**데이터 소스**|**내용**|**데이터 예**
-----|-----|-----
열람 로그|특정 아이템과 유사한 아이템을 추천해서 사용자의 선택지를 늘릴 수 있음|여행용 가방을 구매한다고 할 때 크기, 형태, 색이 다른것을 추천한다
구매 로그|함께 구매 가능한 상품을 추천해서 구매 단가를 끌어 올릴 수 있음|여행용 가방을 구매한다고 할 때 함께 구매하면 좋은 여권 케이스 등을 추천

- 상품 구매 때
  - `크기 차이`, `색상 차이`, `다른 메이커의 유사 상품`등을 비교하면서 구매를 결정하는 사용자가 있음
  - 이러한 사용자의 행동을 기록한 **열람 로그**를 기반으로 추천 시스템을 구축하면
    - 어떤 상품에 대해서 `크기`, `형태`, `색`등이 다른 유사 상품을 추천해줄 수 있음
- 이처럼 **유사 상품**을 추천하면, 구매 유도가 가능
- **구매 로그**를 기반으로 추천 시스템을 구축하면
  - 함께 구매하는 상품, 이어서 구매하는 상품 처럼
  - **열람 로그**와는 또다른 결과를 얻을 수 있음

### 정리
- 추천 시스템에는 다양한 목적, 효과 모듈이 존재
- 추천 시스템의 정의를 확실하게 하고
  - 어떤 효과를 기대하는지 등을 구체화 한 뒤, 시스템을 구축하는 것을 추천

## 2. 특정 아이템에 흥미가 있는 사람이 함께 찾아보는 아이템 검색
- 개념
  - SQL : `SUM(CASE~)`, `ROW_NUMBER` 함수
  - 분석 : 백터 내적, L2 정규화(Norm Nomalize), 코사인 유사도
- 사용자의 **접근 로그**를 사용해서 만들 수 있는 추천 시스템 중에서도,
  - 간단하고, 효과가 높은 추천시스템
  - `특정 아이템에 흥미가 있는 사람이 함께 찾아보는 아이템` -> **Item to Item 추천**
- Item to Item 추천
  - `User to Item` 추천과 비교하여, 구현이 쉽고 효과적인 이유는
  - 일반적인 시스템은 **사용자 유동성 > 아이템 유동성**으로, 데이터를 축적하기 더 쉽기 때문
  - 사용자보다 아이템은 지속해서 사이트에 공개 되는등, 접근 로그가 꾸준히 유지됨
- 사용자의 흥미/관심은 꾸준히 변화하나,
  - 아이템의 연관성은 시간이 지나도 **크게 변하지 않음**
- 오래된 로그를 활용해도, 큰 문제가 되지 않음
- 다만, 뉴스 기사 처럼 아이템 자체가 유동적인 경우에는
  - 이러한 장점을 누릴 수 없으므로 유의

### 접근 로그를 사용해 아이템의 상관도 계산하기
- **접근 로그**에는
  - **사용자별 아이템 열람**과 **구매 액션**이 저장되어 있음
  - **23.1**에서도 설명했듯이, **열람 로그**와 **구매 로그**의 특징을 잘 활용하면, 더 효과적으로 추천 가능
- **접근 로그**와 **구매 로그**를 동시에 다루는 **범용 쿼리**
  - 두 가지의 **가중치**를 변경해서 **열람 기반 추천**과 **구매 기반 추천**에 활용할 수 있는 코드 확인
- 다음 코드는 **로그를 기반으로** 사용자와 아이템 **조합**을 구하고 점수를 계산하는 쿼리
  - 사용자 단위의 `아이템 열람 수 : 구매 수 = 3:7` 비율로 가중치를 두어, 평균을 구하고
    - 이를 사용자의 아이템에 대한 관심도 점수로 사용

#### CODE.23.1. 열람 수와 구매 수를 조합한 점수를 계산하는 쿼리
- `PostgreSQL`, `Hive`, `Redshift`, `BigQuery`, `SparkSQL`
  ```sql
  WITH
  ratings AS (
    SELECT
      user_id
      , product
      -- 상품 열람 수
      , SUM(CASE WHEN action = 'view' THEN 1 ELSE 0 END) AS view_count
      -- 상품 구매 수
      , SUM(CASE WHEN action = 'purchase' THEN 1 ELSE 0 END) AS purchase_count
      -- 열람 수 : 구매 수 = 3:7 비율의 가중치 주어 평균 계산
      , 0.3 * SUM(CASE WHEN action='view' THEN 1 ELSE 0 END)
        + 0.7 * SUM(CASE WHEN action='purchase' THEN 1 ELSE 0 END)
        AS score
    FROM
      action_log
    GROUP BY
      user_id, product
  )
  SELECT *
  FROM
    ratings
  ORDER BY
    user_id, score DESC
  ;
  ```
- 사용자의 아이템에 관한 흥미를 **수치화*** 했을 경우,
  - 그 점수를 조합하여, 아이템 사이의 **유사도**를 계산
- 다음 코드는 **아이템 사이의 유사도**를 계산하고, 순위에 따라 출력하는 쿼리

#### CODE.23.2. 아이템 사이의 유사도를 계산하고 순위를 생성하는 쿼리
- `PostgreSQL`, `Hive`, `Redshift`, `BigQuery`, `SparkSQL`
  ```sql
  WITH
  ratings AS (
    -- CODE.23.1.
  )
  SELECT
    r1.product AS target
    , r2.product AS related
    -- 모든 아이템을 열람/구매한 사용자 수
    , COUNT(r1.user_id) AS users
    -- 스코어들을 곱하고 합계를 구해 유사도 계산
    , SUM(r1.socre * r2.score) AS score
    -- 상품의 유사도 순위 계산
    , ROW_NUMBER()
        OVER(PARTITION BY r1.product ORDER BY SUM(r1.score * r2.score) DESC)
      AS rank
  FROM
    ratings AS r1
    JOIN
      ratings AS r2
      -- 공통 사용자가 존재하는 상품의 페어 만들기
      ON r1.user_id = r2.user_id
  WHERE
    -- 같은 아이템의 경우에는 페어 제외하기
    r1.product <> r2.product
  GROUP BY
    r1.product, r2.product
  ORDER BY
    target, rank
  ;
  ```
- 아이템들의 유사도를 계산하려면
  - 양쪽 아이템을 **모두 열람**하거나 **구매한 사용자**가 필요
- 따라서 `ratings` 테이블을 **사용자 ID**로 자기 결합하고
  - 공통 사용자가 존재하는 **아이템 페어**를 생성
- 이후, 같은 아이템으로 만들어지는 페어는 **제외**하고,
  - 아이템 페어를 집약한 뒤, **유사도**를 계산
- 2개의 아이템에 대한 **사용자의 점수**를 곱하여 **유사도**를 집계
  - **벡터의 내적**
  - 벡터 : 어떤 아이템에 대해 부여된 사용자의 점수를 나열한 **숫자의 집합**
  - 곱한 점수가 높을수록 **유사도**가 높음

### 점수 정규화 하기
- 단순히 **백터 내적**을 사용한 유사도는, 실적용시 **정밀도 문제**가 발생
  - 접근수가 많은 아이템의 유사도가 **상대적으로 높게 평가**
  - 점수의 값이 **어느정도의 유사도**를 나타내는지 점수만으로 확인이 어려움
    - 해당 점수가 높은 것인지, 낮은 것인지 판단이 어려움
    - 다른 아이템과 비교해서 상대적인 점수의 위치를 확인해야 함
- 이에 해결책은 **벡터 정규화**
- 벡터 정규화
  - 벡터를 모두 **같은 길이**로 만든다는 의미
  - 벡터의 각 수치를 **제곱** 후 더한 뒤, 제곱근을 취한 것 -> **벡터의 길이**
- 두 점간의 거리를 계산할 때 사용하는 `Euclidean distance`(유클리드 거리) 정의와 동일
- norm : 벡터의 크기
  - 벡터의 각 수치를 나누면, 벡터의 `norm = 1`
  - 이렇게 정규화 하는 방식을 `L2 정규화` 또는 `2 norm 정규화`라고 부름
- 다음 코드는
  - 사용자의 아이템에 대한 점수 집합을 **아이템 벡터**로 만든 이후, **L2 정규화**하는 쿼리
  - 벡터 norm의 계산에는 `SUM()`, `OVER()`함수와 `SORT()`함수를 사용
  - 이렇게 구한 `norm`으로 각각의 점수를 나누어 `norm_score`를 계산

#### CODE.23.3. 아이템 벡터를 L2 정규화하는 쿼리
- `PostgreSQL`, `Hive`, `Redshift`, `BigQuery`, `SparkSQL`
  ```sql
  WITH
  ratings AS (
    -- CODE.23.1.
  )
  , product_base_normalized_ratings AS (
    -- 아이템 벡터 정규화하기
    SELECT
      user_id
      , product
      , score
      , SQRT(SUM(score * score) OVER(PARTITION BY product)) AS norm
      , score / SQRT(SUM(score * score) OVER(PARTITION BY product)) AS norm_score
    FROM
      ratings
  )
  SELECT *
  FROM
    prodduct_base_normalized_ratings
  ;
  ```
- 정규화 시에 무조건 벡터의 크기는 **1**
- 이어, 정규화된 점수를 사용하여 **아이템의 유사도**를 계싼
  - 코드 예에서는 **같은 아이템 페어**도 함께 유사도 계산

#### CODE.23.4. 정규화된 점수로 아이템의 유사도를 계산하는 쿼리
- `PostgreSQL`, `Hive`, `Redshift`, `BigQuery`, `SparkSQL`
  ```sql
  WITH
  ratings AS (
    -- CODE.23.1.
  )
  , product_base_normalized_ratings AS (
    -- CODE.23.3.
  )
  SELECT
    r1.product AS target
    , r2.product AS related
    -- 모든 아이템을 열람/구매 한 사용자 수
    , COUNT(r1.user_id) AS users
    -- 스코어들을 곱하고 합계를 구해 유사도 계산하기
    , SUM(r1.norm_score * r2.norm_score) As score
    -- 상품의 유사도 순위 구하기
    , ROW_NUMBER()
      OVER(PARTITION BY r1.product ORDER BY SUM(r1.norm_score * r2.norm_score) DESC)
      AS rank
  FROM
    product_base_normalized_ratings AS r1
    JOIN
      product_base_normalized_ratings AS r2
      -- 공통 사용자가 존재하면 상품 페어 만들기
      ON r1.user_id = r2.user_id
  GROUP BY
    r1.product, r2.product
  ORDER BY
    target, rank
  ;
  ```
- 위 쿼리의 결과로
  - 같은 아이템 페어의 유사도는 **반드시 1**
  - 벡터를 정규화 하면, 자기 자신과의 내적값은 반드시 `1`이 되며, 내적의 최댓값 역시 `1`
- 모든 벡터의 값이 **양수**라면,
  - **내적의 최솟값은 0**
- 값의 의미
  - 내적의 값이 0; 유사성이 없는 아이템
  - 내적의 값이 1; 완전히 일치하는 아이템
- 벡터를 `L2 정규화`하여 내적한 값
  - `2개의 벡터를` `n`차원에 매핑하였을 때, 이루는 각도에 `cos`값을 취한 값과 동일
  - `코사인 유사도`라고 부름

### 정리
- 아이템 유사도를 계산하는 방법, **벡터의 내적**
- 이때 벡터로 `아이템 조회 수`와 `구매 수`를 사용하였은데,
  - 실제 서비스 추천시 사용하려면, **서비스 특성에 고려하여 벡터 구성**

## 3. 당신을 위한 추천 상품
- 개념
  - SQL : `SUM(CASE ~)`, `ROW_NUMBER` 함수
  - 분석 : 벡터 내적, L2 정규화, 코사인 유사도
- 당신을 위한 추천 상품(User to Item)
  - 사용자와 관련된 추천
  - 웹사이트 최상위 페이지
  - 사용자의 마이 페이지
  - 검색 결과가 나오지 않았을 경우 출력하는 페이지는 물론이고,
    - 메일 매거진, 푸시 통지 등의 다양한 상황에 활용할 수 있음
- `Item to Item`은 아이템의 유사도만 계산하면 되지만
  - `User to Item`은
    - **사용자와 사용자의 유사도**를 계산하고,
    - **유사 사용자가 흥미를 가진 아이템**을 구매해야 함
- 다음 코드는 **사용자들의 유사도**를 계산하는 쿼리
  - `L2 정규화`를 적용하기는 했으나,
  - 사용자의 **백터 내적**을 계산할 수 있게, 사용자별로 **벡터 노름**을 계산

### CODE.23.5. 사용자끼리의 유사도를 계산하는 쿼리
- `PostgreSQL`, `Hive`, `Redshift`, `BigQuery`, `SparkSQL`
  ```sql
  WITH
  ratings AS (
    -- CODE.23.1.
  )
  , user_base_normalized_ratings AS (
    -- 사용자 벡터 정규화하기
    SELECT
      user_id
      , product
      , score
      -- PARTITION BY user_id으로 사용자별 벡터 노름 계산하기
      , SORT(SUM(score * score) OVER(PARTITION BY user_id)) AS more
      , score / SORT(SUM(score * score) OVER(PARTITION BY user_id)) AS norm_score
    FROM
      ratings
  )
  , related_users AS (
    -- 경향이 비슷한 사용자 찾기
    SELECT
      r1.user_id
      , r2.user_id AS related_user
      , COUNT(r1.product) AS products
      , SUM(r1.norm_score * r2.norm_score) AS score
      , ROW_NUMBER()
          OVER(PARTITION BY r1.user_id ORDER BY SUM(r1.norm_score * r2.norm_score) DESC) AS rank
    FROM
      user_base_normalized_ratings AS r1
      JOIN
        user_base_normalized_ratings AS r2
        ON r1.product = r2.product
    WHERE
      r1.user_id <> r2.user_id
    GROUP BY
      r1.user_id, r2.user_id
  )
  SELECT *
  FROM
    related_users
  ORDER BY
    user_id, rank
  ;
  ```
- 유사 사용자 순위를 계산했다면,
  - 유사 사용자가 흥미 있어 하는 아이템 목록을 추출하고 **아이템 순위**를 만듭니다.
- 다음 코드는 **높은 순위**에 있는 유사 사용자를 기반으로 **추천 아이템**을 추천하는 쿼리
- 유사 사용자 전체를 사용해 **아이템 목록**을 추출하면 계산량이 너무 많아짐
- 낮은 순위의 **유사 사용자**는 큰 의미가 없는 데이터를 만들어낼 가능성이 있습니다.
  - 유사도 상위 `n`명을 사용해 추천 상품을 계산하고 있습니다.
- 추천 상품의 아이템에는 사용자가
  - 기존에 구매한 상품이 포함될 수 있음
- 이 코드에 구매한 상품을 제외하는 코드를 넣는다면 더욱 효율적으로 추천할 수 있음

### CODE.23.6. 순위가 높은 유사 사용자를 기반으로 추천 아이템을 추출하는 쿼리
- `PostgreSQL`, `Hive`, `Redshift`, `BigQuery`, `SparkSQL`
  ```sql
  WITH
  ratings AS (
    -- CODE.23.1.
  )
  , user_base_normalized_ratings AS (
    -- CODE.23.5.
  )
  , related_users AS (
    -- CODE.23.5.
  )
  , related_user_base_products AS (
    SELECT
      u.user_id
      , r.product
      , SUM(u.score * r.score) * AS score
      , ROW_NUMBER()
          OVER(PARTITION BY u.user_id ORDER BY SUM(u.score * r.score) DESC)
      AS rank
    FROM
      related_users AS u
      JOIN
        ratings AS r
        ON u.related_user = r.user_id
    WHERE
      u.rank <= 1
    GROUP BY
      u.user_id, r.product
  )
  SELECT *
  FROM
    related_user_base_products
  ORDER BY
    user_id
  ;
  ```
- 사용자의 **아이템 구매 수**를 활용해 이미 구매한 아이템을 필터링하는 쿼리는 다음과 같음
- 구매하지 않은 상품만 결과로 출력할 것이므로
  - `User to Item` 결과에 `LEFT JOIN`으로 구매 수를 결합하고, 
    - 아이템의 구매가 `0`또는 `NULL`인 아이템을 압축한 뒤 순위를 생성합니다

### CODE.23.7. 이미 구매한 아이템을 필터링하는 쿼리
- `PostgreSQL`, `Hive`, `Redshift`, `BigQuery`, `SparkSQL`
  ```sql
  WITH
  ratings AS (
    -- CODE.23.1.
  )
  , user_base_normalized_ratings AS (
    -- CODE.23.5.
  )
  , related_suers AS (
    -- CODE.23.5.
  )
  , related_user_base_products AS (
    -- CODE.23.6.
  )
  SELECT
    p.user_id
    , p.product
    , p.score
    , ROW_NUMBER()
        OVER(PARTITION BY p.user_id ORDER BY p.score DESC) AS rank
  FROM
    related_user_base_products AS p
    LEFT JOIN
      ratings AS r
      ON p.user_id = r.user_id
      AND p.product = r.product
  WHERE
    -- 대상 사용자가 구매하지 않은 상품만 추천하기
    COALESCE(r.purchase_count, 0) = 0
  ORDER BY
    p.user_id
  ;
  ```
- `User to Item`의 경우 등록한지 얼마 안 된
  - 사용자와 게스트 사용자는, 데이터가 충분하지 않으므로, 제대로 예측하기가 어려움
- 따라서 등록하지 얼마 안 되는 사용자는 `User to Item`이 아닌
  - 다른 추천 로직(랭킹 또는 콘텐츠 기반)을 적용하는 것이 좋음
- 그 밖에 게스트로 사용자 전체를 한 명으로 가정하고, `User to Item`을 만들어 대응하는 방법도 있음

### 정리
- 이번 절에서 소개한 **사용자 행동 로그**를 기반으로 **유사 아이템**을 찾고
  - 추천하는 등의 기능은 **협업 필터링**이라고 부르는 개념의 한가지 구현 방법
- **협업 필터링**에는
  - 기계 학습을 통한 더 발전적인 방법도 많으므로,
  - 다른 방법도 활용해서 다양한 추천에 도전해볼 것

## 4. 추천 시스템을 개선할 때의 포인트 
- 추천 시스템은
  - **서비스 사용자가 원하는 정보와 예측한 내용**
  - **서비스 사용자가 원하는 것**
  - 이 일치할 때 최적의 효과를 발휘함
- 하지만, **추천 시스템**을 만들었다고 해서, 반드시 일치할 수 있는 것은 아님
- 지속적으로 추천 시스템의 **개선** 및 **테스트**가 필요하며,
  - 정밀도를 높일 수 있어야 함

### 값과 리스트 조작에서 개선할 포인트
- 가중치, 필터, 정렬

#### 가중치
- `열람 로그`와 `구매 데이터`를 데이터 소스로 사용할 경우
  - `열람 로그 : 1, 구매 로그 :3`정도로 지정해야, 효율적인 추천 가능
#### 필터
- 추천을 이끌어내기에 데이터가 **부족**하거나, **비정상 데이터**가 있을 경우
  - 이들을 제외하여 **추천의 정밀도**를 높일 수 있음
- 실제 서비스를 운영하다 보면
  - 비정상적인 어뷰징이나, **스팸 공격**을 하는 경우가 존재
  - 이러한 **비정상 로그**는 제외하는 것이 좋음
- 추가로 사용자의 **데모 그래픽**정보를 기반으로
  - 성별에 따라 **추천 점수 가중치**를 다르게 주거나
  - 추천할 아이템의 **카테고리**와 **지역**을 제한하면
    - 더 이해하기 쉬운 **추천**을 만들 수 있음
#### 정렬
- **추천**이란 어떤 점수를 내고, 그 점수를 기반으로 **정렬**하여 사용자에게 제공하는 것
- 이때 어떤 점수를 낼 것인지는, 목적에 따라 다를 수 있음
- 예를 들어,
  - 새로운 아이템을 추천하고 싶은 경우, **신규성**(Novelty) 점수를 정의
  - 매출을 높이고 싶다면, **아이템의 가격** 또는 **기대 구매수**를 고려하여 점수를 정의
- 목적에 따라 **지표**를 정의하고,
  - 이를 기반으로 **정렬**하여 추천을 제공하면, 다양한 개선을 이끌어낼 수 있음

#### 예시
- `음식점 리뷰 사이트 추천`의 경우
  - 별점은 높지만 멀리있는 매장과, 별점이 낮지만 가까운 곳에 있는 매장에 따라 기준을 정할 수 있음
  - 예를 들어 `거리 / 별점`으로 구한 점수를 기반으로 **사용자에게 추천 매장 제공**시
    - 단순하게 별점으로 추천 매장을 제공할때와 비교해 또 다른 느낌을 줄 수 있음

### 구매 방법에 따른 개선 포인트
- 4단계
  - 데이터 수집
  - 데이터 가공
  - 데이터 계산
  - 데이터 정렬
- 위에서 언급한 `가중치`, `필터`, `정렬`을 활용해 어떤 개선을 할 수 있을지 정리하면 다음과 같음

#### 데이터 수집
- 데이터가 존재하지 않는다면 **추천 시스템 자체를 만들 수 없음**
- 구축하고 싶은 `추천의 로직과 모듈`에 따라
  - 수집해야할 **데이터**를 결정하고 수집해야 함
- 이때 `구매 데이터`만으로 추천 시스템을 구축하기 보다는
  - `리뷰 데이터`, `열람 데이터`, `상품 데이터`, `데모 그래픽` 데이터처럼, 다양한 데이터를 사용하는 것이 **정밀도**를 높일 수 있음
- 추가로 **열람 로그**를 사용해 추천 시스템을 구축했는데, `효과가 없을 경우`
  - 다른 데이터들이 준비되어있다면, 다른 방법을 사용해 **추천 시스템을 수정**하기도 쉬움
- 즉, **데이터 수집 단계**에서는 **다양한 데이터를 많이 수집**하는 것이 포인트

#### 데이터 가공
- 데이터를 수집한 이후 **점수**를 계산하기 쉬운 형태로 **가공**하고
  - `비정상적인 데이터`를 제외해두면, 시스템의 정밀도를 높일 수 있음
- 데이터를 신뢰할 수 없다면, 이후 작업은 아무 의미가 없기 때문에
  - `비정상 데이터`를 제외하는 작업은 매우 중요
- 추가로 **유행**(시간의 변화)또는 **계절** 등에 따라서 **사람들의 기호**는 변할 수 있음
  - 따라서 평가 기간을 `한정`하거나, **가중치를 다르게 주는 방법**을 도입하면, 더 정확한 추천 결과를 얻을 수 있음

#### 데이터 계산
- 넓은 의미에서 추천시스템은 **순위를 구한 로직**이라고 할 수 있음
- 데이터들과의 **관계**를 계산하는 것보다도
  - 단순하게 **매출 순서로 정렬**하는 로직을 사용하는게 더 좋을 수 있음
- 추가로 이번 절에서 소개했던 **추천 로직**이외에 다양한 로직이 존재
- 어떠한 로직을 채용하는것이 좋을지 찾아보면
  - **추천 시스템의 정밀도**를 높일 수 있음
- 추가로 로직을 따로 변경하지 않아도
  - **데모그래픽 정보**(성별 또는 나이)등에 따라 **점수 계산 방법**을 다르게하면
  - 또 다른 결과를 얻을 수 있음

#### 데이터 정렬
- 점수를 계산한 결과를 곧바로 `API`에서 응답하면 서비스에서 활용할 수 있지만
  - 이 단계에서 **필터링**과 **정렬 처리**등을 추가하면 더 효율적인 추천 목록을 만들 수 있음
- 예를 들어 `음식점을 당일 예약`하려는 사용자는
  - 현재 위치에서 가장 가까운 음식점을 찾을 가능성이 높
  - 따라서 이러한 추천의 경우, 추천 결과로 나온 음식점을 **거리에 따라 정렬**한다면, 사용자의 행동 욕구를 높일 수 있음
- 추가로 **데모그래픽**정보를 사용해 정렬하면
  - 신규성, 다양성, 의외성을 전달 할 수 있음
- 따라서 서비스에 따라 더 높은 효과를 기대할 수 있음
- 참고로, **반복**해 구매하는 **소비성 상품**은 이미 구매한 제품을 **재추천**해도 상관 없음
- 하지만 일반적인 상품은, 기구매한 상품을 추천해주어도
  - **큰 효과를 거둘 수 없음**

### 정리
- 추천을 개선하려면 **점수 계산 로직**변경 뿐만 아니라,
  - 단계별로 **다양한 상황**을 고려해야 함
- 약간의 수정만으로도 완전히 바뀔 수 있음
- 추천 효과가 없어도 포기하지말고 **다양한 시도**를 하여 개선할 것
- 이 책에서 소개한 **개선 방법**은 극히 일부이므로, 다양한 자료를 찾아보면 좋음

## 5. 출력할 때 포인트
- **추천 목록을 출력**할 때 개선할 수 있는 부분

### 출력 페이지, 위치, 시점 검토하기
- 다양한 서비스의 **추천 모듈 출력 위치**를 비교해보면, 꽤나 특별함
  - 추천 모듈이 **상품 정보**보다 **위**에 출력
    - 사용자에게 더 많은 **선택지**를 보여 주고 싶어함
  - 추천 모듈이 **상품 정보**보다 **아래**의 출력
    - 상품 정보를 우선시하여, **사용자의 중간 이탈**을 막고자 함
- 예시
  - 장바구니에 상품을 추가한 후, 장바구니 내부의 상품을 볼수 있게 페이지 이동이 일어나는 경우
  - **장바구니 화면**에서 **사용자**에게 관련 상품을 추천해 줌
  - 이는 상품 구매중에는 **이탈**을 막고, 상품 구매를 완료하면 **새로운 선택지** 제공
- **열람 로그**를 중심으로 만들어진 추천목록에는
  - 유사한 **색**, **형태**, **크기**의 상품이 들어 있음
- 하지만 같은 카테고리의 상품을 **2개 이상** 구매하는 사용자는 많지 않음
- 따라서 이러한 경우, **열람 로그**가 아니라 **구매 로그**를 기반으로 함께 구매하는 상품
  - 함께 사용할 가능성이 있는 상품을 추천하는것이 효과적
- 즉, **페이지**에 따라 **어떤 추천**을 보여줄지도 중요함

### 추천의 이유
- 단순하게 `추천 상품`이라는 제목으로 아이템을 추천하기 보다
  - `이 상품을 구매한 사람은 이러한 상품도 구매 했습니다`
  - `당신이 구매한 어떤 상품을 기반으로 추천합니다` 등을 함께 보여주면
    - 추천 이유를 **사용자에게 명확하게 전달** 가능 -> 효과 발생
- 추가로
  - 보통 사람들은, 자신이 아는 사람이 좋게 평가한 것을 더 좋게 생각하는 경향(`인지 편향`)과 더불어,
  - 많은 사람이 좋다고 평가한 것을 더 좋게 생각하는 경향(`편승 효과`)가 존재
- 따라서 **소셜 미디어**는 이러한 **경향**을 기반으로 **추천 제공**을 하기도 함

### 크로스셀을 염두한 추천하기
- **함께 자주 구매**하는 상품은
  - 두 제품을 함께 장바구니에 담을 수 있게 하는 버튼을 만들어 구매 유도

### 서비스와 함께 제공하기
- `구매 금액이 5만원 이상`일 때 `무료 배송`을 하는 서비스가 있다면
  - 현재 장바구니 금액이 `5만원 미만`일 때
  - `다음과 같은 상품을 함께 구매하면 배송 무료`라고 출력하는 것만으로도
    - 다양한 효과 유도 가능

### 정리
- 이번 절에서 정리한 내용은
  - **추천 로직**뿐만 아니라 **추천 모듈**을 출력할 때 개선할 수 있는 내용
- 이외에도 다양한 **개선 방법**이 있으므로
  - 실제 **추천 모듈**을 살펴보며 조사해보면 좋음

## 6. 추천과 관련한 지표
- 추천 시스템을 구축시에
  - 웹사이트의 **CTR**, **CVR**, **추천**을 통한 매출 등을 집계하는 것도 하나의 방법
- 이 방법들은 로직과 관련한 직접적인 지표가 아니므로,
  - 추천 시스템에서 어떤 부분을 개선해야 좋을지 **명확한 판단**을 내리기 어려움
- `Microsoft Research` 기술 리포트 중 `Shani Guy`가 작성한 `Evaluation Recommender System(2009)`
  - 추천 시스템을 구축할 때의 평가 방법
  - 평가 지표 등이 자세히 나타남

### TABLE.23.6. 추천 시스템의 대표적인 평가 지표 목록
- **Coverage**
  - 전체 사용자와 아이템 중에 추천이 제공되는 사용자와 아이템의 비율을 나타내는 값
- **Confidence**
  - `(시스템적인)` 추천 아이템의 신뢰도를 나타내는 값
  - 어떤 **아이템**을 추천하기 위해 사용한 **데이터양**이 많으면 `Confidence`가 높음
- **Trust**
  - `(사용자적인)` 추천 아이템의 신뢰도를 나타내는 값
  - 사용자에게 추천이 제대로 되는지 물어보는 방법으로 얻어냄
- **Novelty**
  - 추천된 아이템의 신규성을 나타내는 값
- **Serendipity**
  - 뜻밖의 아이템을 추천하는지를 나타내는 값
- **Diversity**
  - 추천된 아이템의 다양성을 나타내는 값
- **Utility**
  - 서비스 추천의 유익성을 나타내는 값
- **Risk**
  - 리스크를 포함한 아이템(e.g. 주식)을 추천할 때 고려해야 함
- **Robustness**
  - DOS 공격 등의 있을 때 추천 내용이 왜국되지는 않는지 나타내는 값
- **Privacy**
  - 추천 내용을 통해 개인 정보를 추측할 수 있는지를 나타내는 값
- **Adaptivity**
  - 아이템이 업데이트와 유행 등의 변화에 잘 대응할 수 있는지 나타내는 값
- **Scalability**
  - 데이터의 양이 늘어났을 때 대응할 수 있을지 나타내는 값

### 예시
- `Coverage`는 **추천 기능**이 제공되는 **사용자/아이템 수**를
  - 전체 **사용자/아이템 수**로 나누면 구할 수 있음
- `Coverage`가 기대보다 낮으면 **추천 알고리즘 개선**을 검토하고,
- 추천을 제공할 수 없는 `사용자/아이템`의 경우 **다른 모듈**을 활용해서 **비슷한 기능**을 제공하는 방법을 고려할 수 있음
  - 대표적인 예로 **21.8**의 순위 모듈을 제공
- 추천 결과의 **정밀도**뿐만 아니라
  - 데이터가 많아졌을 때의 **처리 시간 전망**처럼 시스템적인 관점에서도 **추천 시스템**을 고려해야하므로, 여러 관점에서 살펴보기
