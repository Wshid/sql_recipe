# 23. 추천
- 추천 시스템(Recommendation System)
  - 사용자의 **흥미 기호**를 분석해서,
  - 사용자가 관심을 가질만한 정보를 추출하는 것이 아닌
    - **사용자에게 가치 있는 정보를 추천하는 것**으로 정의
  - 이를 활용하면
    - 사용자가 아직 모르는 정보를 알려주어, 구매를 유도할 수 있음
- 이번 절에서는
  - 추천에 관련한 기본적인 내용과
  - Item to Item, User to Item 추천 리스트 만들기
- 샘플 데이터
  - 아이템 열람/구매 로그(action_log)
    - stamp, user_id, action, product

## 1. 추천 시스템의 넓은 의미
- 추천 시스템의 의미는 **좁은 의미**와 **넓은 의미**가 다르기 때문에, 혼동될 수 있음
- 넓은 의미의 추천 시스템을 사용하여
  - 추천 시스템의 종류, 모듈, 효과, 정밀도를 살펴보기

### 추천시스템의 종류
- 두가지 종류
  - `Item to Item`
    - 열람/구매한 아이템을 기반으로 다른 아이템을 추천
    - 아이템과 관련한 개별적인 아이템 제안
    - e.g. 이 상품을 본 사람들은 다음 상품도 보았습니다.
  - `User to Item`
    - 과거의 행동 또는 데모그래픽 정보를 기반으로, 흥미와 기호를 유추, 아이템 추천
    - 사용자 개인에 최적화된 아이템 제안
    - e.g. 당신을 위한 추천 아이템 
- `당신을 위한 추천 아이템`이라 적혀 있더라도,
  - 내부 로직이 **최근 구매한 아이템**을 기반으로 다음 아이템을 추천하는 것이라면
  - Item to Item을 의미
- `Item to Item`과 `User to Item`은
  - 모두 상품 또는 기사 단위의 추천이 아니더라도,
  - 상품 카테고리 또는 지역 추천 같은 **포괄적인 추천**도 추천의 대상으로 삼음
- `User to Item`처럼 사용자 **행동**을 기반으로 흥미 기호를 추천하는 경우,
  - 데이터가 적은 사용자에 대해서는 **흥미 기호**를 제대로 판단할 수 없으므로 주의 필요

### 모듈의 종류
- 일반적으로 사용되는 `EC 사이트`에는 어떤 추천 모듈이 있는지 구분
- 모듈의 종류

**모듈**|**설명**|**예**
-----|-----|-----
리마인드|사용자의 과거 행동을 기반으로 아이템을 다시 제안|최근 보았던 상품 / 한 번 더 구매하기
순위|열람 수, 구매 수 등을 기반으로 인기 있는 아이템을 제안해주는 것|인기 순위 / 급상승 순위
콘텐츠베이스|아이템의 추가 정보를 기반으로 다른 아이템을 추천해주는 것|해당 배우가 출연한 다른 작품
추천|서비스를 사용하는 사용자 전체의 행동 이력을 기반으로, 다음에 볼만한 아이템 또는 관련 아이템을 추측해 제안해주는 것|이 상품을 보았던 사람들은 이러한 상품들도 함께 보았습니다
개별 추천|사용자 개인의 행동 이력을 기반으로 흥미 기호를 추천하고, 흥미 있어 할 만한 아이템을 제안해주는 것|당신만을 위한 추천

- 어려운 계산 로직을 사용하지 않더라도
  - `과거에 출력한 정보를 여람 이력으로 출력해주는 모듈`도 `리마인드 목적의 추천 모듈`로 구분
- 예시
  - `매출`또는 `열람 수`에서 상위를 차지하는 몇 개를 출력해주는 것 역시 **순위**를 사용한 추천
    - 매출 또는 열람 수의 상위를 구하는 방법은 **CHAP.10**, **CHAP.14.2**에서 소개됨
  - 추가로 **계절성**을 중시하는 순위라면
    - **CHAP.10.3**에서 소개한 **증가율**을 정렬 점수로 사용하여
      - **급상승 순위**와 동일한 모듈 사용 가능
- 추천/개별 추천(Personal Recommendation)은 **23.2, 23.3**에서 소개

### 추천의 효과
- 추천 시스템은
  - 정보가 과다한 상태에서 **사용자가 가치있는 정보를 쉽게 접하도록** 도와주는 기능
- 이외에도 `EC 사이트`에서 추천의 효과는 다음과 같음

**효과**|**설명**|**출력 예**
-----|-----|-----
다운셀|가격이 높아 구매를 고민하는 사용자에게 더 저렴한 아이템을 제안해서 구매 수를 올리는 것|이전 모델이 가격 할인을 시작했습니다
크로스셀|관련 상품을 함께 구매하게 해서 구매 단가를 올린느 것|함께 구매되는 상품이 있습니다
업셀|상위 모델 또는 고성능의 아이템을 제안해서 구매 단가를 올리는 것|이 상품의 최신 모델이 있습니다

- 예시(햄버거 가게 이야기)
  - `햄버거와 함께 프렌치프라이는 어떤가요?` -> **크로스셀**
  - `500원만 추가하면 프렌치프라이 사이즈를 L로 변경할 수 있습니다` -> **업셀**
  - `작은 사이즈의 커피가 있는데, 가격이 더 저렴합니다` -> **다운셀**
- 사용자가 한 번 방문할 때마다 **이동률**과 **열람 수**를 올리려면
  - 새로운 상품 또는 인기 상품 이외에도
  - 열람수가 적은 상품을 추천해 **새로운 발견**(의외성)을주어야 함
- 이처럼 추천 시스템을 구축할 때는
  - 그 목적을 **명확**하게 하는 것이 중요

### 데이터에 따라 얻을 수 있는 정밀도와 효과의 차이
- 추천 시스템을 구축할 때 중시해야할 점은
  - **어떤 데이터**를 기반으로 **추천 시스템**을 구축할 것인가
- 기존에는 db에 저장된 구매 데이터, 회원 데이터만 사용할 수 있었으나,
  - 최근에는 빅데이터 기술의 진보로 **상품 열람 로그**도 다룰 수 있게 됨
- 사용할 수있는 각종 데이터를 어떻게 수집하고
  - 어떻게 사용할지에 따라 얻는 효과가 다름

#### 데이터의 명시적 획득과 암묵적 획득
- 추천 시스템 구축시 사용할 데이터 수집 방법(2)
  - **사용자 행동**에서 기호를 추측하는 **암묵적인 데이터 획득**
  - 사용자의 기호를 직접 묻는 **명시적 데이터 획득**

**데이터 기반**|**설명**|**데이터 예**
-----|-----|-----
암묵적 데이터 획득|사용자의 행동을 기반으로 기호를 추측한다<br />데이터 양이 많지만 정확도가 떨어질 수 있다|구매 로그<br/>열람 로그
명시적 데이터 획득|사용자에게 직접 기호를 물어본다<br />데이터양이 적지만 평가의 정확성이 높다|별점 주기

- 암묵적 데이터 획득은
  - 구매 했다면 **분명 이상품에 기호가 있을 것이다**라는 전제를 기반으로
  - **구매 데이터**를 추천 시스템의 데이터 소스로 활용
  - 단, 상품 구매가 **반드시 사용자의 기호와 이어지는지는 불분명**
    - e.g. DVD를 구매했으나, 재미 없었음 등
- 명시적 데이터 획득
  - `별점 주기`등을 사용해서, 사용자의 기호를 정확하게 수집하는 방법
  - 사람들이 별점을 주지 않는 경우도 많으므로, 암묵적 데이터 획득보다 **데이터 수가 적음**
- 추가로 추천 시스템 중에는 **무엇을 기반으로 추천**하는지 알려주어
  - 사용자를 납득시키는 경우도 존재
- 단, 명시적으로 획득한 데이터는 **근거**를 보여도 문제가 없으나
  - 암묵적 데이터의 경우, 사용자가 **사생활 침해**로 여길 수 있음

#### 열람 로그와 구매 로그 차이
- 암묵적 데이터를 사용할 경우, **열람 로그**와 **구매 로그**중에
  - 무엇을 사용할지에 따라 추천되는 정보가 다를 수 있음 

**데이터 소스**|**내용**|**데이터 예**
-----|-----|-----
열람 로그|특정 아이템과 유사한 아이템을 추천해서 사용자의 선택지를 늘릴 수 있음|여행용 가방을 구매한다고 할 때 크기, 형태, 색이 다른것을 추천한다
구매 로그|함께 구매 가능한 상품을 추천해서 구매 단가를 끌어 올릴 수 있음|여행용 가방을 구매한다고 할 때 함께 구매하면 좋은 여권 케이스 등을 추천

- 상품 구매 때
  - `크기 차이`, `색상 차이`, `다른 메이커의 유사 상품`등을 비교하면서 구매를 결정하는 사용자가 있음
  - 이러한 사용자의 행동을 기록한 **열람 로그**를 기반으로 추천 시스템을 구축하면
    - 어떤 상품에 대해서 `크기`, `형태`, `색`등이 다른 유사 상품을 추천해줄 수 있음
- 이처럼 **유사 상품**을 추천하면, 구매 유도가 가능
- **구매 로그**를 기반으로 추천 시스템을 구축하면
  - 함께 구매하는 상품, 이어서 구매하는 상품 처럼
  - **열람 로그**와는 또다른 결과를 얻을 수 있음

### 정리
- 추천 시스템에는 다양한 목적, 효과 모듈이 존재
- 추천 시스템의 정의를 확실하게 하고
  - 어떤 효과를 기대하는지 등을 구체화 한 뒤, 시스템을 구축하는 것을 추천

## 2. 특정 아이템에 흥미가 있는 사람이 함께 찾아보는 아이템 검색
- 개념
  - SQL : `SUM(CASE~)`, `ROW_NUMBER` 함수
  - 분석 : 백터 내적, L2 정규화(Norm Nomalize), 코사인 유사도
- 사용자의 **접근 로그**를 사용해서 만들 수 있는 추천 시스템 중에서도,
  - 간단하고, 효과가 높은 추천시스템
  - `특정 아이템에 흥미가 있는 사람이 함께 찾아보는 아이템` -> **Item to Item 추천**
- Item to Item 추천
  - `User to Item` 추천과 비교하여, 구현이 쉽고 효과적인 이유는
  - 일반적인 시스템은 **사용자 유동성 > 아이템 유동성**으로, 데이터를 축적하기 더 쉽기 때문
  - 사용자보다 아이템은 지속해서 사이트에 공개 되는등, 접근 로그가 꾸준히 유지됨
- 사용자의 흥미/관심은 꾸준히 변화하나,
  - 아이템의 연관성은 시간이 지나도 **크게 변하지 않음**
- 오래된 로그를 활용해도, 큰 문제가 되지 않음
- 다만, 뉴스 기사 처럼 아이템 자체가 유동적인 경우에는
  - 이러한 장점을 누릴 수 없으므로 유의

### 접근 로그를 사용해 아이템의 상관도 계산하기
- **접근 로그**에는
  - **사용자별 아이템 열람**과 **구매 액션**이 저장되어 있음
  - **23.1**에서도 설명했듯이, **열람 로그**와 **구매 로그**의 특징을 잘 활용하면, 더 효과적으로 추천 가능
- **접근 로그**와 **구매 로그**를 동시에 다루는 **범용 쿼리**
  - 두 가지의 **가중치**를 변경해서 **열람 기반 추천**과 **구매 기반 추천**에 활용할 수 있는 코드 확인
- 다음 코드는 **로그를 기반으로** 사용자와 아이템 **조합**을 구하고 점수를 계산하는 쿼리
  - 사용자 단위의 `아이템 열람 수 : 구매 수 = 3:7` 비율로 가중치를 두어, 평균을 구하고
    - 이를 사용자의 아이템에 대한 관심도 점수로 사용

#### CODE.23.1. 열람 수와 구매 수를 조합한 점수를 계산하는 쿼리
- `PostgreSQL`, `Hive`, `Redshift`, `BigQuery`, `SparkSQL`
  ```sql
  WITH
  ratings AS (
    SELECT
      user_id
      , product
      -- 상품 열람 수
      , SUM(CASE WHEN action = 'view' THEN 1 ELSE 0 END) AS view_count
      -- 상품 구매 수
      , SUM(CASE WHEN action = 'purchase' THEN 1 ELSE 0 END) AS purchase_count
      -- 열람 수 : 구매 수 = 3:7 비율의 가중치 주어 평균 계산
      , 0.3 * SUM(CASE WHEN action='view' THEN 1 ELSE 0 END)
        + 0.7 * SUM(CASE WHEN action='purchase' THEN 1 ELSE 0 END)
        AS score
    FROM
      action_log
    GROUP BY
      user_id, product
  )
  SELECT *
  FROM
    ratings
  ORDER BY
    user_id, score DESC
  ;
  ```
- 사용자의 아이템에 관한 흥미를 **수치화*** 했을 경우,
  - 그 점수를 조합하여, 아이템 사이의 **유사도**를 계산
- 다음 코드는 **아이템 사이의 유사도**를 계산하고, 순위에 따라 출력하는 쿼리

#### CODE.23.2. 아이템 사이의 유사도를 계산하고 순위를 생성하는 쿼리
- `PostgreSQL`, `Hive`, `Redshift`, `BigQuery`, `SparkSQL`
  ```sql
  WITH
  ratings AS (
    -- CODE.23.1.
  )
  SELECT
    r1.product AS target
    , r2.product AS related
    -- 모든 아이템을 열람/구매한 사용자 수
    , COUNT(r1.user_id) AS users
    -- 스코어들을 곱하고 합계를 구해 유사도 계산
    , SUM(r1.socre * r2.score) AS score
    -- 상품의 유사도 순위 계산
    , ROW_NUMBER()
        OVER(PARTITION BY r1.product ORDER BY SUM(r1.score * r2.score) DESC)
      AS rank
  FROM
    ratings AS r1
    JOIN
      ratings AS r2
      -- 공통 사용자가 존재하는 상품의 페어 만들기
      ON r1.user_id = r2.user_id
  WHERE
    -- 같은 아이템의 경우에는 페어 제외하기
    r1.product <> r2.product
  GROUP BY
    r1.product, r2.product
  ORDER BY
    target, rank
  ;
  ```
- 아이템들의 유사도를 계산하려면
  - 양쪽 아이템을 **모두 열람**하거나 **구매한 사용자**가 필요
- 따라서 `ratings` 테이블을 **사용자 ID**로 자기 결합하고
  - 공통 사용자가 존재하는 **아이템 페어**를 생성
- 이후, 같은 아이템으로 만들어지는 페어는 **제외**하고,
  - 아이템 페어를 집약한 뒤, **유사도**를 계산
- 2개의 아이템에 대한 **사용자의 점수**를 곱하여 **유사도**를 집계
  - **벡터의 내적**
  - 벡터 : 어떤 아이템에 대해 부여된 사용자의 점수를 나열한 **숫자의 집합**
  - 곱한 점수가 높을수록 **유사도**가 높음

### 점수 정규화 하기
- 단순히 **백터 내적**을 사용한 유사도는, 실적용시 **정밀도 문제**가 발생
  - 접근수가 많은 아이템의 유사도가 **상대적으로 높게 평가**
  - 점수의 값이 **어느정도의 유사도**를 나타내는지 점수만으로 확인이 어려움
    - 해당 점수가 높은 것인지, 낮은 것인지 판단이 어려움
    - 다른 아이템과 비교해서 상대적인 점수의 위치를 확인해야 함
- 이에 해결책은 **벡터 정규화**
- 벡터 정규화
  - 벡터를 모두 **같은 길이**로 만든다는 의미
  - 벡터의 각 수치를 **제곱** 후 더한 뒤, 제곱근을 취한 것 -> **벡터의 길이**
- 두 점간의 거리를 계산할 때 사용하는 `Euclidean distance`(유클리드 거리) 정의와 동일
- norm : 벡터의 크기
  - 벡터의 각 수치를 나누면, 벡터의 `norm = 1`
  - 이렇게 정규화 하는 방식을 `L2 정규화` 또는 `2 norm 정규화`라고 부름
- 다음 코드는
  - 사용자의 아이템에 대한 점수 집합을 **아이템 벡터**로 만든 이후, **L2 정규화**하는 쿼리
  - 벡터 norm의 계산에는 `SUM()`, `OVER()`함수와 `SORT()`함수를 사용
  - 이렇게 구한 `norm`으로 각각의 점수를 나누어 `norm_score`를 계산

#### CODE.23.3. 아이템 벡터를 L2 정규화하는 쿼리
- `PostgreSQL`, `Hive`, `Redshift`, `BigQuery`, `SparkSQL`
  ```sql
  WITH
  ratings AS (
    -- CODE.23.1.
  )
  , product_base_normalized_ratings AS (
    -- 아이템 벡터 정규화하기
    SELECT
      user_id
      , product
      , score
      , SQRT(SUM(score * score) OVER(PARTITION BY product)) AS norm
      , score / SQRT(SUM(score * score) OVER(PARTITION BY product)) AS norm_score
    FROM
      ratings
  )
  SELECT *
  FROM
    prodduct_base_normalized_ratings
  ;
  ```
- 정규화 시에 무조건 벡터의 크기는 **1**
- 이어, 정규화된 점수를 사용하여 **아이템의 유사도**를 계싼
  - 코드 예에서는 **같은 아이템 페어**도 함께 유사도 계산

#### CODE.23.4. 정규화된 점수로 아이템의 유사도를 계산하는 쿼리
- `PostgreSQL`, `Hive`, `Redshift`, `BigQuery`, `SparkSQL`
  ```sql
  WITH
  ratings AS (
    -- CODE.23.1.
  )
  , product_base_normalized_ratings AS (
    -- CODE.23.3.
  )
  SELECT
    r1.product AS target
    , r2.product AS related
    -- 모든 아이템을 열람/구매 한 사용자 수
    , COUNT(r1.user_id) AS users
    -- 스코어들을 곱하고 합계를 구해 유사도 계산하기
    , SUM(r1.norm_score * r2.norm_score) As score
    -- 상품의 유사도 순위 구하기
    , ROW_NUMBER()
      OVER(PARTITION BY r1.product ORDER BY SUM(r1.norm_score * r2.norm_score) DESC)
      AS rank
  FROM
    product_base_normalized_ratings AS r1
    JOIN
      product_base_normalized_ratings AS r2
      -- 공통 사용자가 존재하면 상품 페어 만들기
      ON r1.user_id = r2.user_id
  GROUP BY
    r1.product, r2.product
  ORDER BY
    target, rank
  ;
  ```
- 위 쿼리의 결과로
  - 같은 아이템 페어의 유사도는 **반드시 1**
  - 벡터를 정규화 하면, 자기 자신과의 내적값은 반드시 `1`이 되며, 내적의 최댓값 역시 `1`
- 모든 벡터의 값이 **양수**라면,
  - **내적의 최솟값은 0**
- 값의 의미
  - 내적의 값이 0; 유사성이 없는 아이템
  - 내적의 값이 1; 완전히 일치하는 아이템
- 벡터를 `L2 정규화`하여 내적한 값
  - `2개의 벡터를` `n`차원에 매핑하였을 때, 이루는 각도에 `cos`값을 취한 값과 동일
  - `코사인 유사도`라고 부름

### 정리
- 아이템 유사도를 계산하는 방법, **벡터의 내적**
- 이때 벡터로 `아이템 조회 수`와 `구매 수`를 사용하였은데,
  - 실제 서비스 추천시 사용하려면, **서비스 특성에 고려하여 벡터 구성**